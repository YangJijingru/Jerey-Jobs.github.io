---
tags: 
 - DP-状压
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P35.jpg"
preview-img: "/img/preview/P35.jpg"
---
<p style="margin:0px">
	<span style="font-weight:bold"><span style="font-size:16px;"><span style="font-family:Microsoft YaHei;">标签：状压<span style="margin:0px" lang="EN-US">DP</span></span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Description</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-size:16px;"><span style="font-family:Microsoft YaHei;">混乱的奶牛<span style="margin:0px" lang="EN-US"> [Don Piele, 2007] Farmer John</span>的<span style="margin:0px" lang="EN-US">N(4 &lt;= N &lt;= 16)</span>头奶牛中的每一头都有一个唯一的编号<span style="margin:0px" lang="EN-US">S_i (1&lt;= S_i &lt;= 25,000). </span>奶牛为她们的编号感到骄傲<span style="margin:0px" lang="EN-US">, </span>所以每一头奶牛都把她的编号刻在一个金牌上<span style="margin:0px" lang="EN-US">, </span>并且把金牌挂在她们宽大的脖子上<span style="margin:0px" lang="EN-US">.</span>奶牛们对在挤奶的时候被排成一支<span style="margin:0px" lang="EN-US">&quot;</span>混乱<span style="margin:0px" lang="EN-US">&quot;</span>的队伍非常反感<span style="margin:0px" lang="EN-US">.</span>如果一个队伍里任意两头相邻的奶牛的编号相差超过<span style="margin:0px" lang="EN-US">K (1 &lt;= K &lt;=3400),</span>它就被称为是混乱的<span style="margin:0px" lang="EN-US">. </span>比如说，当<span style="margin:0px" lang="EN-US">N = 6, K= 1</span>时<span style="margin:0px" lang="EN-US">, 1, 3, 5, 2, 6, 4</span>就是一支<span style="margin:0px" lang="EN-US">&quot;</span>混乱<span style="margin:0px" lang="EN-US">&quot;</span>的队伍<span style="margin:0px" lang="EN-US">,</span>但是<span style="margin:0px" lang="EN-US"> 1, 3,6, 5, 2, 4 </span>不是<span style="margin:0px" lang="EN-US">(</span>因为<span style="margin:0px" lang="EN-US">5</span>和<span style="margin:0px" lang="EN-US">6</span>只相差<span style="margin:0px" lang="EN-US">1).</span>那么<span style="margin:0px" lang="EN-US">,</span>有多少种能够使奶牛排成<span style="margin:0px" lang="EN-US">&quot;</span>混乱<span style="margin:0px" lang="EN-US">&quot;</span>的队伍的方案呢<span style="margin:0px" lang="EN-US">?</span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Input</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-size:16px;"><span style="font-family:Microsoft YaHei;"><span style="margin:0px" lang="EN-US">*</span>第<span style="margin:0px" lang="EN-US"> 1</span>行<span style="margin:0px" lang="EN-US">:</span>用空格隔开的两个整数<span style="margin:0px" lang="EN-US">N</span>和<span style="margin:0px" lang="EN-US">K</span></span></span>
</p>
<p style="margin:0px">
	<span style="font-size:16px;"><span style="font-family:Microsoft YaHei;"><span style="margin:0px" lang="EN-US">*</span>第<span style="margin:0px" lang="EN-US"> 2..N+1</span>行<span style="margin:0px" lang="EN-US">:</span>第<span style="margin:0px" lang="EN-US">i+1</span>行包含了一个用来表示第<span style="margin:0px" lang="EN-US">i</span>头奶牛的编号的整数<span style="margin:0px" lang="EN-US">: S_i</span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Output</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-size:16px;"><span style="font-family:Microsoft YaHei;">第<span style="margin:0px" lang="EN-US"> 1</span>行<span style="margin:0px" lang="EN-US">:</span>只有一个整数<span style="margin:0px" lang="EN-US">,</span>表示有多少种能够使奶牛排成<span style="margin:0px" lang="EN-US">&quot;</span>混乱<span style="margin:0px" lang="EN-US">&quot;</span>的队伍的方案<span style="margin:0px" lang="EN-US">.</span>答案保证是 一个在<span style="margin:0px" lang="EN-US">64</span>位范围内的整数<span style="margin:0px" lang="EN-US">.</span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Input</span></span></strong>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">4 1</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">3</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">4</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">2</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">1</span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Output</span></span></strong>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">2</span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;">输出解释<span style="margin:0px" lang="EN-US">:</span></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;">两种方法分别是<span style="margin:0px" lang="EN-US">:</span></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">3 1 4 2</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">2 4 1 3</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span><span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">题意：给定长度为<span style="margin:0px" lang="EN-US">N</span>的数列<span style="margin:0px" lang="EN-US">s</span>，定义混乱的队伍为存在相邻两项<span style="margin:0px" lang="EN-US">s[i]</span>与<span style="margin:0px" lang="EN-US">s[i+1]</span>的差值大于<span style="margin:0px" lang="EN-US">K</span>，问有多少种重新排列使得奶牛变成混乱的队伍</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">状态：<span style="margin:0px" lang="EN-US">F[i][j]</span>表示前<span style="margin:0px" lang="EN-US">i</span>头奶牛状态为<span style="margin:0px" lang="EN-US">j</span>的方案数</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei"><span style="font-size:16px;">转移：<span style="margin:0px" lang="EN-US">f[k][(1&lt;&lt;(k-1))|j]+=f[i][j]<span style="margin:0px">&nbsp;</span></span>条件：<span style="margin:0px" lang="EN-US">abs(a[k]-a[i])&gt;K</span>且其中<span style="margin:0px" lang="EN-US">k</span>不包含在状态<span style="margin:0px" lang="EN-US">i</span>中，<span style="margin:0px" lang="EN-US">j</span>包含在状态<span style="margin:0px" lang="EN-US">i</span>中<span style="margin:0px" lang="EN-US">.</span></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><br />
	</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Code</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"></span>
</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define LL long long
#define mem(x,num) memset(x,num,sizeof x)
using namespace std;
inline LL read()
{
	LL f=1,x=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
LL n,K,tt,a[20],t[20],f[20][1&lt;&lt;16],ans;
int main()
{
	n=read(),K=read();
	rep(i,1,n)a[i]=read(),t[i]=1&lt;&lt;(i-1);
	rep(i,1,n)f[i][t[i]]=1;
	rep(i,0,(1&lt;&lt;n)-1)
	    rep(j,1,n)
	        if(t[j]&amp;i)
				rep(k,1,n)
			        if((t[k]|i)!=i&amp;&amp;abs(a[j]-a[k])&gt;K)f[k][t[k]|i]+=f[j][i];
    rep(i,1,n)ans+=f[i][(1&lt;&lt;n)-1];
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre>
<br />

<p>
	<br />
	
</p>
