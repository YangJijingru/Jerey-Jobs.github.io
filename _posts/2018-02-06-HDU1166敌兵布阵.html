---
tags: 
 - 数据结构-线段树
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P25.jpg"
preview-img: "/img/preview/P65.jpg"
---
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>http://www.sakurasake.icoc.me/nd.jsp?id=4#_np=2_327<br />
	</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>HDU1166敌兵布阵</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>标签：线段树</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Time Limit: 2000/1000 MS(Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br />
	<br />
	</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Problem Description</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。<br />
	中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:&quot;你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：&quot;我知错了。。。&quot;但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Input</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">第一行一个整数T，表示有T组数据。<br />
	每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。<br />
	接下来每行有一条命令，命令有4种形式：<br />
	(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br />
	(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br />
	(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br />
	(4)End 表示结束，这条命令在每组数据最后出现;<br />
	每组数据最多有40000条命令</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Output</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">对第i组数据,首先输出“Case i:”和回车,<br />
	对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Sample Input</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">10</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1 2 3 4 5 6 7 8 9 10</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Query 1 3</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Add 3 6</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Query 2 7</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Sub 10 2</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Add 6 3</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Query 3 10</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">End </span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Sample Output</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Case 1:</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">6</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">33</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">59</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">分析：线段树是一种二叉平衡树，记为t[a,b]，参数[a,b]表示区间[a,b]，其中b-a可以看做区间的长度</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">若b-a&gt;1，那么[a,(a+b)/2]为t的左儿子，[(a+b)/2,b]为t的右儿子</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">若b-a==1，那么该t为叶子结点</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">线段树这种数据结构需要使用结构体封装</span>
</p>
<pre name="code" class="cpp"><span style="font-family:Microsoft YaHei;font-size:16px;">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
inline int read()
{
    int f=1,x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
using namespace std;
struct
{
    int a,b,sum;//a,b分别表示左右端点，sum表示a-b区间内所有叶子结点//权值的和
}t[140000];
int people[50010],sum;

void make(int x,int y,int num)
{
    t[num].a=x;
    t[num].b=y;
    if(x==y) t[num].sum=people[y];//如果当前为叶子结点，则直接赋值返回
    else
    {
        make(x,(x+y)/2,num*2);//继续制造左子树
        make((x+y)/2+1,y,num*2+1);//制造右子树
        t[num].sum=t[num+num].sum+t[num+num+1].sum;//修改sum域的值
    }
}

void add(int i,int j,int num)//将第i个工地增加j个人，num表示线段的序号
{
    t[num].sum+=j;
    if(t[num].a==i&amp;&amp;t[num].b==i)return;
    if(i&gt;(t[num].a+t[num].b)/2)
        add(i,j,num*2+1);
    else add(i,j,num*2);
}

void sub(int i,int j,int num)
{
    t[num].sum-=j;
    if(t[num].a==i&amp;&amp;t[num].b==i)return;//如果恰好找到a-b区间，则直接//返回
    if(i&gt;(t[num].a+t[num].b)/2)
        sub(i,j,num*2+1);//继续修改右子树
    else sub(i,j,num*2);//修改左子树
}

void query(int i,int j,int num)
{
    if(i&lt;=t[num].a&amp;&amp;j&gt;=t[num].b)sum+=t[num].sum;//找到了要求的区间，返回值
    else
    {
        int k=(t[num].a+t[num].b)/2;
        if(i&gt;k)query(i,j,num*2+1);//查询的线段在右子树
        else if(j&lt;=k)query(i,j,num*2);//查询的线段在左子树
        else
        {
            query(i,j,num*2);
            query(i,j,num*2+1);
        }//查询的线段在该线段中间，分段查询，左右子树都查询
    }
}

int main(int argc,char* argv[])
{
    int n,t,i,j;
    char command[6];
    t=read();
    j=0;
    while(t--)
    {
        int a,b;
        n=read();
        people[0]=0;
        for(i=1;i&lt;=n;i++)
            people[i]=read();//读入每个工地的人数
        make(1,n,1);//建立线段树
        printf(&quot;Case &quot;);
        printf(&quot;%d:\n&quot;,++j);
        while(scanf(&quot;%s&quot;,command))
        {
            if(strcmp(command,&quot;End&quot;)==0)break;
            else if(strcmp(command,&quot;Query&quot;)==0)
            {
                a=read();b=read();
                sum=0;//初始为0
                query(a,b,1);//从根节点开始查询，目标区间为a-b
                printf(&quot;%d\n&quot;,sum);
            }
            else if(strcmp(command,&quot;Add&quot;)==0)
            {
                a=read();b=read();
                add(a,b,1);//从根节点开始修改，目标区间为a-b
            }
            else if(strcmp(command,&quot;Sub&quot;)==0)
            {
                a=read();b=read();
                sub(a,b,1);
            }
        }
    }
    return 0;
}
</span></pre>
<br />