---
tags: 
 - 图论-最小生成树
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P36.jpg"
preview-img: "/img/preview/P36.jpg"
---
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">标签：并查集，最小生成树</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">tips:bzoj这题为权限题，可以去洛谷2916提交</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Description</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#333333;">Farmer John</span><span style="color:#333333;">变得非常懒</span><span style="color:#333333;">,</span><span style="color:#333333;">他不想再继续维护供奶牛之间供通行的道路</span><span style="color:#333333;">.</span><span style="color:#333333;">道路被用来连接</span><span style="color:#333333;">N (5 &lt;= N &lt;=10,000)</span><span style="color:#333333;">个牧场</span><span style="color:#333333;">,</span><span style="color:#333333;">牧场被连续地编号为</span><span style="color:#333333;">1..N.</span><span style="color:#333333;">每一个牧场都是一个奶牛的家</span><span style="color:#333333;">. FJ</span><span style="color:#333333;">计划除去</span><span style="color:#333333;">P(N-1 &lt;= P &lt;=100,000)</span><span style="color:#333333;">条道路中尽可能多的道路</span><span style="color:#333333;">,</span><span style="color:#333333;">但是还要保持牧场之间的连通性</span><span style="color:#333333;">.</span><span style="color:#333333;">你首先要决定那些道路是需要保留的</span><span style="color:#333333;">N-1</span><span style="color:#333333;">条道路</span><span style="color:#333333;">.</span><span style="color:#333333;">第</span><span style="color:#333333;">j</span><span style="color:#333333;">条双向道路连接了牧场</span><span style="color:#333333;">S_j</span><span style="color:#333333;">和</span><span style="color:#333333;">E_j (1 &lt;= S_j &lt;= N; 1&lt;= E_j &lt;= N; S_j != E_j), </span><span style="color:#333333;">而且走完它需要</span><span style="color:#333333;">L_j (0 &lt;= L_j&lt;= 1,000)</span><span style="color:#333333;">的时间</span><span style="color:#333333;">.</span><span style="color:#333333;">没有两个牧场是被一条以上的道路所连接</span><span style="color:#333333;">.</span><span style="color:#333333;">奶牛们非常伤心</span><span style="color:#333333;">,</span><span style="color:#333333;">因为她们的交通系统被削减了</span><span style="color:#333333;">.</span><span style="color:#333333;">你需要到每一个奶牛的住处去安慰她们</span><span style="color:#333333;">.</span><span style="color:#333333;">每次你到达第</span><span style="color:#333333;">i</span><span style="color:#333333;">个牧场的时候</span><span style="color:#333333;">(</span><span style="color:#333333;">即使你已经到过</span><span style="color:#333333;">),</span><span style="color:#333333;">你必须花去</span><span style="color:#333333;">C_i (1 &lt;= C_i&lt;= 1,000)</span><span style="color:#333333;">的时间和奶牛交谈</span><span style="color:#333333;">.</span><span style="color:#333333;">你每个晚上都会在同一个牧场</span><span style="color:#333333;">(</span><span style="color:#333333;">这是供你选择的</span><span style="color:#333333;">)</span><span style="color:#333333;">过夜</span><span style="color:#333333;">,</span><span style="color:#333333;">直到奶牛们都从悲伤中缓过神来</span><span style="color:#333333;">.</span><span style="color:#333333;">在早上起来和晚上回去睡觉的时候</span><span style="color:#333333;">,</span><span style="color:#333333;">你都需要和在你睡觉的牧场的奶牛交谈一次</span><span style="color:#333333;">.</span><span style="color:#333333;">这样你才能完成你的交谈任务</span><span style="color:#333333;">.</span><span style="color:#333333;">假设</span><span style="color:#333333;">Farmer John</span><span style="color:#333333;">采纳了你的建议</span><span style="color:#333333;">,</span><span style="color:#333333;">请计算出使所有奶牛都被安慰的最少时间</span><span style="color:#333333;">.</span><span style="color:#333333;">对于你前</span><span style="color:#333333;">10</span><span style="color:#333333;">次的提交</span><span style="color:#333333;">,</span><span style="color:#333333;">你的程序会在一部分正式的测试数据上运行</span><span style="color:#333333;">,</span><span style="color:#333333;">并且返回运行的结果</span><span style="color:#333333;">.</span></span>
</p>
<div>
	<h2>
		<span style="font-family:Microsoft YaHei;font-size:16px;">Input</span>
	</h2>
</div>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#333333;">*</span><span style="color:#333333;">第</span><span style="color:#333333;"> 1</span><span style="color:#333333;">行</span><span style="color:#333333;">:</span><span style="color:#333333;">用空格隔开的两个整数</span><span style="color:#333333;">N</span><span style="color:#333333;">和</span><span style="color:#333333;">P *</span><span style="color:#333333;">第</span><span style="color:#333333;"> 2..N+1</span><span style="color:#333333;">行</span><span style="color:#333333;">: </span><span style="color:#333333;">第</span><span style="color:#333333;">i+1</span><span style="color:#333333;">行包含了一个整数</span><span style="color:#333333;">: C_i *</span><span style="color:#333333;">第</span><span style="color:#333333;"> N+2..N+P+1</span><span style="color:#333333;">行</span><span style="color:#333333;">:</span><span style="color:#333333;">第</span><span style="color:#333333;"> N+j+1</span><span style="color:#333333;">行包含用空格隔开的三个整数</span><span style="color:#333333;">: S_j, E_j</span><span style="color:#333333;">和</span><span style="color:#333333;"> L_j</span></span>
</p>
<div>
	<h2>
		<span style="font-family:Microsoft YaHei;font-size:16px;">Output</span>
	</h2>
</div>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#333333;">第</span><span style="color:#333333;"> 1</span><span style="color:#333333;">行</span><span style="color:#333333;">:</span><span style="color:#333333;">一个整数</span><span style="color:#333333;">,</span><span style="color:#333333;">所需要的总时间</span><span style="color:#333333;">(</span><span style="color:#333333;">包含和在你所在的牧场的奶牛的两次谈话时间</span><span style="color:#333333;">).</span></span>
</p>
<p>
	<span style="color:#333333;"><span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span></span>
</p>
<div>
	<h2>
		<span style="font-family:Microsoft YaHei;font-size:16px;">Sample Input</span>
	</h2>
</div>
<p>
	<span style="color:#333333;"><span style="font-family:Microsoft YaHei;font-size:16px;">5 7<br />
	10<br />
	10<br />
	20<br />
	6<br />
	30<br />
	1 2 5<br />
	2 3 5<br />
	2 4 12<br />
	3 4 17<br />
	2 5 15<br />
	3 5 6<br />
	4 5 12<br />
	<br />
	</span></span>
</p>
<div>
	<h2>
		<span style="font-family:Microsoft YaHei;font-size:16px;">Sample Output</span>
	</h2>
</div>
<p>
	<span style="color:#333333;"><span style="font-family:Microsoft YaHei;font-size:16px;">176</span></span>
</p>
<div>
	<h2>
		<span style="font-family:Microsoft YaHei;font-size:16px;">HINT</span>
	</h2>
</div>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">分析：每个边权为原本的边权w*2+两个端点的点权</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">之后直接裸的最小生成树模板题</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Code</span>
</p>
<pre name="code" class="cpp">#include&lt;bits/stdc++.h&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
using namespace std;
const int maxn=10010,maxm=100010;
struct edge{int u,v,w;}e[maxm];
int fa[maxn],n,m,c[maxn],ans=1e9,u,v,w,sum=0;
inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline int cmp(edge x,edge y){return x.w&lt;y.w;}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	rep(i,1,n){scanf(&quot;%d&quot;,&amp;c[i]);ans=min(ans,c[i]);fa[i]=i;}
	rep(i,1,m){scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);w=(w&lt;&lt;1)+c[u]+c[v];e[i]=(edge){u,v,w};}
	sort(e+1,e+m+1,cmp);
	rep(i,1,m){
		int root1=find(e[i].u),root2=find(e[i].v);
		if(root1!=root2){
			fa[root1]=root2;sum++;ans+=e[i].w;
		}
		if(sum==n-1)break;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</pre>
<br />
<br />

<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><br />
	</span>
</p>
