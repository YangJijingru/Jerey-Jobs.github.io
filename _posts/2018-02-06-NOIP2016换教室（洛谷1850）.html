---
tags: 
 - DP-杂题
 - 数论-期望
 - 图论-floyd
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P3.jpg"
preview-img: "/img/preview/P43.jpg"
---
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">标签：DP，最短路</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">【题目描述】 <br />
	对于刚上大学的牛牛来说, 他面临的第一个问题是如何根据实际情况中情合适的课程。 <br />
	在可以选择的课程中,有2n节课程安排在n个时间段上。在第 i ( 1≤ i≤n)个时同段上, 两节内容相同的课程同时在不同的地点进行, 其中, 牛牛预先被安排在教室 ci上课, 而另一节课程在教室 di进行。<br />
	在不提交任何申请的情况下,学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室,则需要提出中情。若申请通过,学生就可以在第 i个时间段去教室 di上课, 否则仍然在教室 ci上课。<br />
	由于更换教室的需求太多, 申请不一定能获得通过。 通过计算, 牛牛发现申请更换第 i节课程的教室时, 中情被通过的概率是一个已知的实数 ki, 并且对于不同课程的申请, 被通过的概率是互相独立的。<br />
	学校规定, 所有的申请只能在学期开始前一次性提交, 并且每个人只能选择至多m节课程进行申请。 这意味着牛牛必须一次性决定是否申请更换每节课的教室, 而不能根据某些课程的申请结果来决定其他课程是否申请; 牛牛可以申请白己最希望更换教室的 m门课程,也可以不用完这m个中情的机会,甚至可以一门课程都不申请。<br />
	因为不同的课程可能会被安排在不同的教室进行, 所以牛牛需要利用课问时间从一间教室赶到另一间教室。 <br />
	牛牛所在的大学有 v个教室,有 e条道路。每条道路连接两间教室, 并且是可以双向通行的。 由于道路的长度和拥;i者程度不同, 通过不同的道路耗费的体力可能会有所不同。当第i ( 1≤i≤n-1 )节课结束后,牛牛就会从这节课的教室出发,选择一条耗费体力最少的路径前往下一节课的教室。<br />
	现在牛牛想知道,申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小,请你帮他求出这个最小值。 <br />
	【输入格式】 <br />
	第一行四个整数 n,m,v,e 。 n表示这个学期内的时间段的数量; m表示牛牛最多可以申请更换多少节课程的教室; v表示牛牛学校里教室的数量; e表示牛牛的学校里道路的数量。<br />
	第二行n个正整数,第 i ( 1≤ i≤ n)个正整数表示c,,即第 i个时间段牛牛被安排上课的教室;保证1≤ci≤ v。 <br />
	第三行n个正整数,第 i ( 1≤ i≤ n)个正整数表示di,即第 i个时间段另一间上同样课程的教室;保证1≤di≤ v。 <br />
	第四行n个实数,第 i ( 1≤ i≤ n)个实数表示ki,即牛牛申请在第 i个时间段更换教室获得通过的概率。保证0≤ ki≤1 。 <br />
	接下来 e行,每行三个正整数aj,bj,wj,表示有一条双向道路连接教室 aj ,bj ,通过这条道路需要耗费的体力值是 Wj ;保证1≤ aj,bj≤ v, 1≤ wj≤100 。<br />
	保证1≤n≤2000, 0≤m≤2000, 1≤v≤300, 0≤ e≤90000。 <br />
	保证通过学校里的道路,从任何一间教室出发,都能到达其他所有的教室。 <br />
	保证输入的实数最多包含3位小数。 <br />
	【输出格式】 <br />
	输出一行,包含一个实数,四舎五入精确到小数点后恰好2位,表示答案。你的 <br />
	输出必须和标准输出完全一样才算正确。 <br />
	测试数据保证四舎五入后的答案和准确答案的差的绝对值不大于4 *10^-3 。 (如果你不知道什么是浮点误差, 这段话可以理解为: 对于大多数的算法, 你可以正常地使用浮点数类型而不用对它进行特殊的处理)<br />
	【样例输入】 <br />
	3 2 3 3 <br />
	2 1 2 <br />
	1 2 1 <br />
	0.8 0.2 0.5 <br />
	1 2 5 <br />
	1 3 3 <br />
	2 3 1 <br />
	【样例输出】 <br />
	2.80 <br />
	【数据范围】 <br />
	1&lt;=n&lt;=2000 <br />
	1&lt;=m&lt;=2000 <br />
	1&lt;=v&lt;=300 </span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">【样例1说明】</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">所有可行的申请方案和期望收益如下表:</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">【提示】</span>
</p>
<ol start="1" type="1">
	<li>
		<span style="font-family:Microsoft YaHei;font-size:16px;">道路中可能会有多条双向道路连接相同的两间教室。 也有可能有道路两端连接</span>
	</li>
</ol>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">的是同一间教室。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">2.请注意区分n,m,v,e的意义, n不是教室的数量, m不是道路的数量。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">特殊性质1:图上任意两点 ai,bi, ai≠ bi间,存在一条耗费体力最少的路径只包含一条道路。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">特殊性质2:对于所有的1≤ i≤ n， ki= 1 。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">483 055 310</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">分析：</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">题目中说了可能会给出起点和终点相同的数据，或是重复给出一条边的权值，这两种情况在读入的时候特判即可，但一定要注意这些细节</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">求任意两个教室之间最短路，先跑遍floyd</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">dis[i,j]表示i,j之间的最短路</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">这题竟然考了数学期望，虽然只是一些基础概念，去年考NOIP的时候一万脸懵逼</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">f[i,j,0]表示到第i次课时申请j次并且该次不申请的期望最小值<br />
	f[i,j,1]表示到第i次课时申请j次并且该次申请的期望最小值</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">转移：</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">当前时间段由上一个时间段申请或者不申请转移</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">f[i][j][0] = min(f[i-1][j][0] + dis[a[i-1]][a[i]],f[i-1][j][1] + dis[a[i-1]][a[i]] (1 -c[i-1]) + dis[b[i-1]][a[i]] c[i-1]);</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">f[i][j][1] = min(f[i-1][j-1][0] + dis[a[i-1]][a[i]](1.0-c[i]) + dis[a[i-1]][b[i]] c[i],</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">f[i-1][j-1][1] + dis[i-1]][a[i]] (1.0-c[i-1]) (1.0-c[i]) + dis[i-1]][a[i]]c[i-1] (1.0-c[i]) + dis[i-1]][b[i]](1.0-c[i-1]) c[i] + dis[i-1]][b[i]]c[i-1] c[i]);</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">参考代码</span>
</p>
<pre name="code" class="cpp"><span style="font-family:Microsoft YaHei;font-size:16px;">#include&lt;bits/stdc++.h&gt;
using namespace std;
inline int read()
{
    int f=1,x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
const int maxn=2005,maxm=305;
int dis[maxm][maxm];
double c[maxn],f[maxn][maxn][2];
int a[maxn],b[maxn];

int main()
{
    int n=read(),m=read(),v=read(),e=read();
    for(int i=0;i&lt;=v;i++)
        for(int j=0;j&lt;=v;j++)
            dis[i][j]=1e9,dis[j][i]=1e9;
    for(int i=0;i&lt;=v;i++)dis[i][i]=0;
    for(int i=0;i&lt;=n;i++)
        for(int j=0;j&lt;=n;j++)
            f[i][j][0]=1e9,f[i][j][1]=1e9;
    f[1][0][0]=0;f[1][1][1]=0;
    for(int i=1;i&lt;=n;i++)a[i]=read();
    for(int i=1;i&lt;=n;i++)b[i]=read();
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;c[i];
    for(int i=1;i&lt;=e;i++)
    {
        int x=read(),y=read(),w=read();
        if(x==y)continue;
        if(w&lt;dis[x][y])dis[x][y]=w;
        dis[y][x]=dis[x][y];
    }
    for(int k=1;k&lt;=v;k++)
        for(int i=1;i&lt;=v;i++)
            for(int j=1;j&lt;=v;j++)
                if(i!=j&amp;&amp;j!=k&amp;&amp;i!=k&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])dis[i][j]=dis[i][k]+dis[k][j];
    for(int i=2;i&lt;=n;i++)
    {
        f[i][0][0]=f[i-1][0][0]+dis[a[i-1]][a[i]];
        for(int j=1;j&lt;=min(i,m);j++)
        {
            f[i][j][0]=min(f[i-1][j][0]+dis[a[i-1]][a[i]],f[i-1][j][1]+dis[b[i-1]][a[i]]*c[i-1]+dis[a[i-1]][a[i]]*(1.0-c[i-1]));
            f[i][j][1]=min(f[i-1][j-1][0]+dis[a[i-1]][a[i]]*(1.0-c[i])+dis[a[i-1]][b[i]]*c[i],
                           f[i-1][j-1][1]+dis[a[i-1]][a[i]]*(1.0-c[i-1])*(1.0-c[i])+
                           dis[b[i-1]][a[i]]*c[i-1]*(1.0-c[i])+
                           dis[a[i-1]][b[i]]*(1.0-c[i-1])*c[i]+
                           dis[b[i-1]][b[i]]*c[i-1]*c[i]);
        }
    }
    double ans=f[n][0][0];
    for(int i=1;i&lt;=m;i++)ans=min(ans,min(f[n][i][0],f[n][i][1]));
    printf(&quot;%.2lf&quot;,ans);
    return 0;
}
</span></pre>
<span style="font-family:Microsoft YaHei;font-size:16px;"><br />
</span><br />

<p>
	<br />
	
</p>
<br />