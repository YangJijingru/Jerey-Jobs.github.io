---
tags: 
 - DP-区间
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P5.jpg"
preview-img: "/img/preview/P5.jpg"
---
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>标签：区间DP</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>题目描述</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">这是一个流行在Jsoi的游戏，名称为祖玛。 精致细腻的背景，外加神秘的印加音乐衬托，彷佛置身在古老的国度里面，进行一个神秘的游戏——这就是著名的祖玛游戏。祖玛游戏的主角是一只石青蛙，石青蛙会吐出各种颜色的珠子，珠子造型美丽，并且有着神秘的色彩，环绕着石青蛙的是载着珠子的轨道，各种颜色的珠子会沿着轨道往前滑动，石青蛙必需遏止珠子们滚进去轨道终点的洞里头，如何减少珠子呢？就得要靠石青蛙吐出的珠子与轨道上的珠子相结合，颜色相同者即可以消失得分！直到轨道上的珠子通通都被清干净为止。或许你并不了解祖玛游戏。没关系。这里我们介绍一个简单版本的祖玛游戏规则。一条通道中有一些玻璃珠，每个珠子有各自的颜色，如图1所示。玩家可以做的是选择一种颜色的珠子（注意：颜色可以任选，这与真实游戏是不同的）射入某个位置。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><img src="http://xheditor.com/js/xheditor_skin/default/img/waiting.gif" remoteimg="0" alt="" /><br />
	</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">图1 图2中玩家选择一颗蓝色珠子，射入图示的位置，于是得到一个图3的局面。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">图2 图3 当玩家射入一颗珠子后，如果射入的珠子与其他珠子组成了三颗以上连续相同颜色的珠子，这些珠子就会消失。例如，将一颗白色珠子射入图4中的位置，就会产生三颗颜色相同的白色珠子。这三颗珠子就会消失，于是得到图5的局面。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">图4 图5 需要注意的一点是，图4中的三颗连续的黄色珠子不会消失，因为并没有珠子射入其中。 珠子的消失还会产生连锁反应。当一串连续相同颜色的珠子消失后，如果消失位置左右的珠子颜色相同，并且长度大于2，则可以继续消失。例如，图6中，射入一颗红色珠子后，产生了三颗连续的红色珠子。当红色珠子消失后，它左右都是白色的珠子，并且一共有四颗，于是白色珠子也消失了。之后，消失位置的左右都是蓝色珠子，共有三颗，于是蓝色珠子也消失。最终得到图7的状态。注意，图7中的三颗黄色珠子不会消失，因为蓝色珠子消失的位置一边是紫色珠子，另一边是黄色珠子，颜色不同。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">图6 图7 除了上述的情况，没有其他的方法可以消去珠子。现在，我们有一排珠子，需要你去消除。对于每一轮，你可以自由选择不同颜色的珠子，射入任意的位置。你的任务是射出最少的珠子，将全部珠子消去。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>输入输出格式</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>输入格式：</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">第一行一个整数n（n ≤ 500），表示珠子的个数第二行n个整数（32位整数范围内），用空格分割，每个整数表示一种颜色的珠子。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>输出格式：</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">一个整数，表示最少需要射出的珠子个数。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>输入输出样例</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>输入样例#1：</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">9</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1 1 2 2 3 3 2 1 1</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>输出样例#1：</strong></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">分析：</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">F[l][r]表示从l-&gt;R最少用珠子次数，先预处理出color[i]和num[i]记录原来珠子序列</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">从前往后处理，如果遇到a[i]≠a[i-1]那么，color[cnt++]=a[i]，同样处理num数组</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Color数组从前往后记录原珠子中不同颜色</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Num数组和color数组一一对应，表示不同颜色的珠子的个数</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">f[l][r]=min(f[l][i]+f[i+1][r],f[i][j]);</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">code</span>
</p>
<pre><code class="language-cpp line-numbers hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dep(i,a,b) for(int i=a;i&gt;=b;i--)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL long long</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem(x,num) memset(x,num,sizeof x)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">506</span>,inf=<span class="hljs-number">0x3f3f3f</span>;
<span class="hljs-keyword">struct</span> node{<span class="hljs-keyword">int</span> num,col;}b[maxn];
<span class="hljs-keyword">int</span> n,cnt,now,num,a[maxn],f[maxn][maxn];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);
    rep(i,<span class="hljs-number">1</span>,n)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);
    mem(f,inf);
    <span class="hljs-keyword">int</span> now=a[<span class="hljs-number">1</span>],cnt=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>;
    rep(i,<span class="hljs-number">1</span>,n){
        <span class="hljs-keyword">if</span>(a[i]!=now){
            b[++cnt].num=num;
            b[cnt].col=now;
            num=<span class="hljs-number">1</span>;
            now=a[i];
        }
        <span class="hljs-keyword">else</span> num++;
        <span class="hljs-keyword">if</span>(i==n){
            b[++cnt].num=num;
            b[cnt].col=now;
        }
    }
    rep(i,<span class="hljs-number">1</span>,cnt){
        <span class="hljs-keyword">if</span>(b[i].num&gt;<span class="hljs-number">1</span>)f[i][i]=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> f[i][i]=<span class="hljs-number">2</span>;
    }
    rep(p,<span class="hljs-number">2</span>,cnt)
        rep(i,<span class="hljs-number">1</span>,cnt-p+<span class="hljs-number">1</span>){
            <span class="hljs-keyword">int</span> j=i+p<span class="hljs-number">-1</span>;
            <span class="hljs-keyword">if</span>(b[i].col==b[j].col){
                <span class="hljs-keyword">if</span>(b[i].num+b[j].num==<span class="hljs-number">2</span>)
                    f[i][j]=f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span> f[i][j]=f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];
            }
            rep(k,i,j<span class="hljs-number">-1</span>)f[i][j]=min(f[i][j],f[i][k]+f[k+<span class="hljs-number">1</span>][j]);
        }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-number">1</span>][cnt]);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<br />

<p>
	<br />
	
</p>
