---
tags: 
 - DP-斜率优化
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P30.jpg"
preview-img: "/img/preview/P30.jpg"
---
<p style="text-align:left" align="center">
	<span style="color:blue;font-weight:bold"><span style="font-family:Microsoft YaHei;font-size:16px;">标签：斜率优化</span></span>
</p>
<p align="left">
	<strong><span style="color:blue;"><span style="font-family:Microsoft YaHei;font-size:16px;">Description</span></span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">　　L公司有N个工厂，由高到底分布在一座山上。如图所示，工厂1在山顶，工厂N在山脚。由于这座山处于高原内<br />
	陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。突然有一天，L公司的总裁L先生接到气象<br />
	部门的电话，被告知三天之后将有一场暴雨，于是L先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于<br />
	地形的不同，在不同工厂建立仓库的费用可能是不同的。第i个工厂目前已有成品Pi件，在第i个工厂位置建立仓库<br />
	的费用是Ci。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于L公司产品的对外销售处设<br />
	置在山脚的工厂N，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，<br />
	假设一件产品运送1个单位距离的费用是1。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到<br />
	以下数据：1：工厂i距离工厂1的距离Xi（其中X1=0）;2：工厂i目前已有成品数量Pi;:3：在工厂i建立仓库的费用<br />
	Ci;请你帮助L公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。</span>
</p>
<p align="left">
	<strong><span style="color:blue;"><span style="font-family:Microsoft YaHei;font-size:16px;">Input</span></span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">　　第一行包含一个整数N，表示工厂的个数。接下来N行每行包含两个整数Xi, Pi, Ci, 意义如题中所述。</span>
</p>
<p align="left">
	<strong><span style="color:blue;"><span style="font-family:Microsoft YaHei;font-size:16px;">Output</span></span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">　　仅包含一个整数，为可以找到最优方案的费用。</span>
</p>
<p align="left">
	<strong><span style="color:blue;"><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Input</span></span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">3<span style="background:rgb(141,184,255)"><br />
	<br />
	</span></span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">0 5 10<span style="background:rgb(141,184,255)"><br />
	<br />
	</span></span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">5 3 100<span style="background:rgb(141,184,255)"><br />
	<br />
	</span></span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">9 6 10</span>
</p>
<p align="left">
	<strong><span style="color:blue;"><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Output</span></span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">32</span>
</p>
<p align="left">
	<strong><span style="color:blue;"><span style="font-family:Microsoft YaHei;font-size:16px;">HINT</span></span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">在工厂1和工厂3建立仓库，建立费用为10+10=20，运输费用为(9-5)*3 = 12，总费用32。如果仅在工厂3建立仓库，建立费用为10，运输费用为(9-0)*5+(9-5)*3=57，总费用67，不如前者优。<br />
	<br />
	【数据规模】<br />
	<br />
	对于100%的数据， N ≤1000000。 所有的Xi, Pi, Ci均在32位带符号整数以内，保证中间计算结果不超过64位带符号整数。&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">F[i]=min{f[j]+work(j+1,i)}</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Work(j+1,i)表示将j+1到i的物品移往i的运输费用</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">难点就是在O（1）的时间内求出work(j+1,i)</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">可以利用前缀和的思想，sum[i]表示p[i]的前缀和</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">如果所有物品都从起始点0开始运到i，则费用为（sum[i]-sum[j]）*x[i]</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">但由于物品的起始点不在0，那么每个物品可以少花费x[i]*p[i]</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">b[i]表示x[i]*p[i]的前缀和</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">那么f[i]=min(f[j]+(sum[i]-sum[j])*x[i]-(b[i]-b[j])+c[i]</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">如果j&gt;k且j比k更优，斜率优化下</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">（f[j]-f[k]+b[j]-b[k]）/&nbsp;(sum[j]-sum[k])&lt; x[i]</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Code</span>
</p>
<pre name="code" class="cpp">#include&lt;bits/stdc++.h&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define LL long long
#define mem(x,num) memset(x,num,sizeof x)
using namespace std;
inline LL read()
{
    LL f=1,x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
const int maxn=1e6+6;
LL n,head,tail,p[maxn],x[maxn],c[maxn],f[maxn],b[maxn],sum[maxn],q[maxn];
inline double slop(int k,int j)
{return (double)(f[j]-f[k]+b[j]-b[k])/(double)(sum[j]-sum[k]);}
 
int main()
{
    n=read();
    rep(i,1,n)x[i]=read(),p[i]=read(),c[i]=read();
    rep(i,1,n){sum[i]=sum[i-1]+p[i];b[i]=b[i-1]+p[i]*x[i];}
    rep(i,1,n){
        while(head&lt;tail&amp;&amp;slop(q[head],q[head+1])&lt;x[i])head++;
        int t=q[head];
        f[i]=f[t]-b[i]+b[t]+(sum[i]-sum[t])*x[i]+c[i];
        while(head&lt;tail&amp;&amp;slop(q[tail-1],q[tail])&gt;slop(q[tail],i))tail--;
        q[++tail]=i;
    }
    cout&lt;&lt;f[n]&lt;&lt;endl;
    return 0;
}</pre>
<br />
<br />

<p>
	<br />
	
</p>
