---
tags: 
 - DP-树形
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P1.jpg"
preview-img: "/img/preview/P1.jpg"
---
<p style="margin:0px">
	<span style="font-weight:bold"><span style="font-family:等线;"><span style="font-size:16px;">标签：树形<span style="margin:0px" lang="EN-US">DP</span></span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">Description</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-family:等线;"><span style="font-size:16px;"><span style="margin:0px" lang="EN-US">&nbsp;&nbsp;&nbsp;</span>首长<span style="margin:0px" lang="EN-US">NOI</span>惨跪，于是去念文化课了。现在，他面对一道化学题。<span style="margin:0px" lang="EN-US"><br />
	&nbsp;&nbsp;&nbsp; </span>这题的来源是因为在一个奇怪的学校两个化竞党在玩一个奇怪的博弈论游戏。这个游戏很蛋疼，我相信你们也没有兴趣听。<span style="margin:0px" lang="EN-US"><br />
	&nbsp;&nbsp;&nbsp; </span>由于这个游戏涉及博弈论，因此化竞的同学就要求首长求一个类似<span style="margin:0px" lang="EN-US">SG</span>函数的值。<span style="margin:0px" lang="EN-US"><br />
	&nbsp;&nbsp;&nbsp; </span>他们手中有一种非常神奇的化合物，它的分子由<span style="margin:0px" lang="EN-US">N</span>个原子组成（不要在意一个原子可能和及其多个原子成键这个细节）。这个分子构成一个树结构，<span style="margin:0px" lang="EN-US">1</span>号分子为根。<span style="margin:0px" lang="EN-US">&nbsp;&nbsp;&nbsp;</span>若两个原子<span style="margin:0px" lang="EN-US">i</span>、<span style="margin:0px" lang="EN-US">j</span>到它们的最近公共祖先的距离分别是<span style="margin:0px" lang="EN-US">Li</span>和<span style="margin:0px" lang="EN-US">Lj</span>，定义它们的<span style="margin:0px" lang="EN-US">Aij</span>值为：<span style="margin:0px" lang="EN-US"><br />
	Aij=Li&nbsp; xor Lj<br />
	</span>题目要求对于每一个<span style="margin:0px" lang="EN-US">k(k∈N)</span>，求出两两<span style="margin:0px" lang="EN-US">A</span>值为<span style="margin:0px" lang="EN-US">k</span>的原子对个数。</span></span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">Input</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-family:等线;"><span style="font-size:16px;"><span style="margin:0px" lang="EN-US">&nbsp;</span>第一行一个整数<span style="margin:0px" lang="EN-US">N</span>。<span style="margin:0px" lang="EN-US"><br />
	&nbsp; </span>接下来<span style="margin:0px" lang="EN-US">N-1</span>行，每行一个整数<span style="margin:0px" lang="EN-US">p</span>，第新亍的整数表示第<span style="margin:0px" lang="EN-US">i</span>个原子的父亲为<span style="margin:0px" lang="EN-US">p</span>。</span></span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">Output</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-family:等线;font-size:16px;">从<span style="margin:0px" lang="EN-US">K=0</span>开始，第<span style="margin:0px" lang="EN-US">k+1</span>行输出两两<span style="margin:0px" lang="EN-US">A</span>值为<span style="margin:0px" lang="EN-US">K</span>的原子对个数，输出到第一个不为零的数为止。</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">Sample Input</span></span></strong>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">3</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">1</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">1</span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">Sample Output</span></span></strong>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">1</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">2</span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">HINT</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-family:等线;"><span style="font-size:16px;">【数据规模与约定】<span style="margin:0px" lang="EN-US"><br />
	</span>用<span style="margin:0px" lang="EN-US">h</span>表示树结构分子的最大深度。<span style="margin:0px" lang="EN-US"><br />
	&nbsp;N&lt;=10^5,H&lt;=500</span></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">&nbsp;</span></span>
</p>
<p style="margin:0px">
	<span style="font-family:等线;"><span style="font-size:16px;">题意：给定一棵树，问有多少对节点（<span style="margin:0px" lang="EN-US">u</span>，<span style="margin:0px" lang="EN-US">v</span>）满足<span style="margin:0px" lang="EN-US">dis(lca(u,v),u) ^ dis(lca(u,v),v)==k</span></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">&nbsp;</span></span>
</p>
<p style="margin:0px">
	<span style="font-family:等线;font-size:16px;">分析：<span style="margin:0px" lang="EN-US">70</span>分<span style="margin:0px" lang="EN-US">n&lt;=3000</span>的暴力很好写</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="font-family:等线;font-size:16px;">正解应该也算暴力吧，枚举每个点和深度，设<span style="margin:0px" lang="EN-US">a[x][i]</span>表示以<span style="margin:0px" lang="EN-US">x</span>为根节点的子树中深度为<span style="margin:0px" lang="EN-US">i</span>的节点个数，直接计算点对数量</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">&nbsp;</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:等线;font-size:16px;">Code</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"></span>
</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define mem(x,num) memset(x,num,sizeof x)
#define LL long long
#define reg(x) for(int i=head[x];i;i=e[i].next)
using namespace std;
inline LL read()
{
	LL f=1,x=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const LL maxn=1e5+6;
LL a[maxn][1&lt;&lt;9],ans[1&lt;&lt;9],head[maxn],deep[maxn],n,cnt=0;
struct edge{LL to,next;}e[maxn&lt;&lt;1];
void dfs(int x)
{
	a[x][0]=1;
	reg(x){
		dfs(e[i].to);
		rep(j,0,deep[x])
		    rep(k,0,deep[e[i].to])ans[j^(k+1)]+=a[x][j]*a[e[i].to][k];
		deep[x]=max(deep[x],deep[e[i].to]+1);
		rep(j,0,deep[x])a[x][j+1]+=a[e[i].to][j];
	}
}

int main()
{
	n=read();
	rep(i,2,n){LL x=read();e[++cnt]=(edge){i,head[x]},head[x]=cnt;}
	dfs(1);
	LL mx=1&lt;&lt;9,t;
	dep(i,mx,1)if(ans[i]){t=i;break;}
	rep(i,0,t)printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}</pre>
<br />

<p>
	<br />
	
</p>
<br />