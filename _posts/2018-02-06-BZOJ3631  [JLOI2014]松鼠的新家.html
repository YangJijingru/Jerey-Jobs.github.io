---
tags: 
 - 树-LCA
 - DP-树形
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P40.jpg"
preview-img: "/img/preview/P80.jpg"
---
<p>
	<strong><span style="font-family:Microsoft YaHei;font-size:16px;">标签：树上差分，lca，树形DP</span></strong>
</p>
<p>
	<strong><span style="font-family:Microsoft YaHei;font-size:16px;">Description</span></strong>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">松鼠的新家是一棵树，前几天刚刚装修了新家，新家有n个房间，并且有n-1根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在“树”上。松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去a1，再去a2，……，最后到an，去参观新家。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">可是这样会导致维尼重复走很多房间，懒惰的维尼不听地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。维尼是个馋家伙，立马就答应了。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。因为松鼠参观指南上的最后一个房间an是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。</span>
</p>
<p>
	<strong><span style="font-family:Microsoft YaHei;font-size:16px;">Input</span></strong>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">第一行一个整数n，表示房间个数</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">第二行n个整数，依次描述a1-an</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">接下来n-1行，每行两个整数x，y，表示标号x和y的两个房间之间有树枝相连。</span>
</p>
<p>
	<strong><span style="font-family:Microsoft YaHei;font-size:16px;">Output</span></strong>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">一共n行，第i行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。</span>
</p>
<p>
	<strong><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Input</span></strong>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">5</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1 4 5 3 2</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1 2</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">2 4</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">2 3</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">4 5</span>
</p>
<p>
	<strong><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Output</span></strong>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">2</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">2</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1<br />
	</span><br />
	
</p>
<p>
	<strong><span style="font-family:Microsoft YaHei;font-size:16px;">HINT</span></strong>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">2&lt;= n &lt;=300000</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">题意：给出一棵树和N-1条边，问每个点被多少条路径覆盖</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">分析：实际上是树剖的裸题，但可以用差分解决</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">可以将每条路径的起止点u,v打上标记+1,lca(u,v)-1,fa[lca(u,v)]-1，最后dp上传标记即可</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Code</span>
</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define mem(X,num) memset(x,num,sizeof x)
#define reg(x) for(int i=head[x];i;i=e[i].next)
#define LL long long
using namespace std;
inline LL read()
{
	LL f=1,x=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int maxn=3e5+6;
LL bin[21],n,cnt=0;
LL fa[maxn][21],a[maxn],deep[maxn],head[maxn],f[maxn];
struct edge{int to,next;}e[maxn&lt;&lt;1];
void dfs(int x)
{
	rep(i,1,19)
	    if(deep[x]&gt;=bin[i])fa[x][i]=fa[fa[x][i-1]][i-1];else break;
	reg(x)
		if(e[i].to!=fa[x][0]){
			deep[e[i].to]=deep[x]+1;
			fa[e[i].to][0]=x;
			dfs(e[i].to);
		}
}
int lca(int x,int y)
{
	if(deep[x]&lt;deep[y])swap(x,y);
	int t=deep[x]-deep[y];
	rep(i,0,19)
	    if(bin[i]&amp;t)x=fa[x][i];
	dep(i,19,0)
		if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	if(x==y)return x;
	return fa[x][0];
}
void dp(int x)
{
	reg(x)
	    if(e[i].to!=fa[x][0]){
			dp(e[i].to);
			f[x]+=f[e[i].to];
		}
}
int main()
{
	bin[0]=1;rep(i,1,20)bin[i]=bin[i-1]&lt;&lt;1;
	n=read();
	rep(i,1,n)a[i]=read();
	rep(i,1,n-1){
		int u=read(),v=read();
		e[++cnt]=(edge){v,head[u]};head[u]=cnt;
		e[++cnt]=(edge){u,head[v]};head[v]=cnt;
	}
	dfs(a[1]);
	rep(i,1,n-1){
		int t=lca(a[i],a[i+1]);
		f[a[i]]++,f[a[i+1]]++;
		f[t]--,f[fa[t][0]]--;
	}
	dp(a[1]);
	rep(i,2,n)f[a[i]]--;
	rep(i,1,n)printf(&quot;%lld\n&quot;,f[i]);
	return 0;
}</pre>
<br />

<p>
	<br />
	
</p>
