---
tags: 
 - 树-LCA
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P38.jpg"
preview-img: "/img/preview/P78.jpg"
---
<p style="text-align:left" align="center">
	<span style="color:blue;"><strong>标签</strong></span><span style="color:blue;"><strong>:LCA,</strong></span><span style="color:blue;"><strong>树</strong></span>
</p>
<p align="left">
	<strong><span style="color:blue;">Description</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	米特是D星球上一种非常神秘的物质，蕴含着巨大的能量。在以米特为主要能源的D星上，这种米特能源的运输和储
</p>
<p style="background:rgb(228,240,248)" align="left">
	存一直是一个大问题。D星上有N个城市，我们将其顺序编号为1到N，1号城市为首都。这N个城市由N-1条单向高速
</p>
<p style="background:rgb(228,240,248)" align="left">
	通道连接起来，构成一棵以1号城市（首部）为根的树，高速通道的方向由树中的儿子指向父亲。树按深度分层：
</p>
<p style="background:rgb(228,240,248)" align="left">
	根结点深度为0，属于第1层；根结点的子节点深度为1，属于第2层；依此类推，深度为i的结点属于第i+l层。建好
</p>
<p style="background:rgb(228,240,248)" align="left">
	高速通道之后，D星人开始考虑如何具体地储存和传输米特资源。由于发展程度不同，每个城市储存米特的能力不
</p>
<p style="background:rgb(228,240,248)" align="left">
	尽相同，其中第i个城市建有一个容量为A[i]的米特储存器。这个米特储存器除了具有储存的功能，还具有自动收
</p>
<p style="background:rgb(228,240,248)" align="left">
	集米特的能力。如果到了晚上六点，有某个储存器处于未满的状态，它就会自动收集大气中蕴含的米特能源，在早
</p>
<p style="background:rgb(228,240,248)" align="left">
	上六点之前就能收集满；但是，只有在储存器完全空的状态下启动自动收集程序才是安全的，未满而又非空时启动
</p>
<p style="background:rgb(228,240,248)" align="left">
	可能有安全隐患。早上六点到七点间，根节点城市（1号城市）会将其储存器里的米特消耗殆尽。根节点不会自动
</p>
<p style="background:rgb(228,240,248)" align="left">
	搜集米特，它只接受子节点传输来的米特。早上七点，城市之间启动米特传输过程，传输过程逐层递进：先是第2
</p>
<p style="background:rgb(228,240,248)" align="left">
	层节点城市向第1层（根节点城市，即1号城市）传输，直到第1层的储存器满或第2层的储存器全为空；然后是第3
</p>
<p style="background:rgb(228,240,248)" align="left">
	层向第2层传输，直到对于第2层的每个节点，其储存器满或其予节点（位于第3层）的储存器全为空；依此类推，
</p>
<p style="background:rgb(228,240,248)" align="left">
	直到最后一层传输完成。传输过程一定会在晚上六点前完成。
</p>
<p style="background:rgb(228,240,248)" align="left">
	由于技术原因，运输方案需要满足以下条件：
</p>
<p style="background:rgb(228,240,248)" align="left">
	(1)不能让某个储存器到了晚上六点传输结束时还处于非空但又未满的状态，这个时候储存器仍然会启动自动收集
</p>
<p style="background:rgb(228,240,248)" align="left">
	米特的程序，而给已经储存有米特的储存器启动收集程序可能导致危险，也就是说要让储存器到了晚上六点时要么
</p>
<p style="background:rgb(228,240,248)" align="left">
	空要么满；
</p>
<p style="background:rgb(228,240,248)" align="left">
	(2)关于首都——即1号城市的特殊情况， &nbsp;每天早上六点到七点间1号城市中的米特储存器里的米特会自动被消耗
</p>
<p style="background:rgb(228,240,248)" align="left">
	殆尽，即运输方案不需要考虑首都的米特怎么运走；
</p>
<p style="background:rgb(228,240,248)" align="left">
	(3)除了1号城市，每个节点必须在其子节点城市向它运输米特之前将这座城市的米特储存器中原本存有的米特全部
</p>
<p style="background:rgb(228,240,248)" align="left">
	运出去给父节点，不允许储存器中残存的米特与外来的米特发生混合；
</p>
<p style="background:rgb(228,240,248)" align="left">
	(4)运向某一个城市的若干个来源的米特数量必须完全相同，不然，这些来源不同的米特按不同比例混合之后可能
</p>
<p style="background:rgb(228,240,248)" align="left">
	发生危险。
</p>
<p style="background:rgb(228,240,248)" align="left">
	现在D星人已经建立好高速通道，每个城市也有了一定储存容量的米特储存器。为了满足上面的限制条件，可能需
</p>
<p style="background:rgb(228,240,248)" align="left">
	要重建一些城市中的米特储存器。你可以，也只能，将某一座城市（包括首都）中屎来存在的米特储存器摧毁，再
</p>
<p style="background:rgb(228,240,248)" align="left">
	新建一座任意容量的新的米特储存器，其容量可以是小数（在输入数据中，储存器原始容量是正整数，但重建后可
</p>
<p style="background:rgb(228,240,248)" align="left">
	以是小数），不能是负数或零，使得需要被重建的米特储存器的数目尽量少。
</p>
<p align="left">
	<strong><span style="color:blue;">Input</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	第一行是一个正整数N，表示城市的数目。接下来N行，每行一个正整数，其中的第i行表示第i个城市原来存在的米
</p>
<p style="background:rgb(228,240,248)" align="left">
	特储存器的容量。再接下来是N-I行，每行两个正整数a，b表示城市b到城市a有一条高速通道(a≠b)。
</p>
<p style="background:rgb(228,240,248)" align="left">
	N&lt;500000，A[j]&lt;10^8
</p>
<p align="left">
	<strong><span style="color:blue;">Output</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	输出文件仅包含一行，一个整数，表示最少的被重建（即修改储存器容量）的米特储存器的数目。
</p>
<p align="left">
	<strong><span style="color:blue;">Sample Input</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	5<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	5<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	4<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	3<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	2<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	1<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	1 2<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	1 3<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	2 4<span style="background:rgb(141,184,255)"><br />
	<br />
	</span>
</p>
<p style="background:rgb(228,240,248)" align="left">
	2 5
</p>
<p align="left">
	<strong><span style="color:blue;">Sample Output</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	3
</p>
<p align="left">
	<strong><span style="color:blue;">HINT</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
	【样例解释】<br />
	<br />
	&nbsp; 一个最优解是将A[1]改成8，A[3]改成4，A[5]改成2。这样，2和3运给1的量相等，4和5运给2的量相等，且每天晚上六点的时候，1，2满，3，4，5空，满足所有限制条件。
</p>
<p>
	分析:
</p>
<p>
	确定了一个节点的权值之后，其他节点的权值都能随之确定
</p>
<p>
	所以计算出每个节点对应的根节点，排个序，乱搞，答案是同一个值出现次数的最大值
</p>
<p>
	因为可能出现数字过大的情况，所以我们对所有数取对数
</p>
<p>
	zz的我还把边表写错了qwq，自己太弱
</p>
<p>
	Code
</p>
<pre name="code" class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define ll long long
#define mem(x,num) memset(x,num,sizeof x)
#define eps 1e-8
#ifdef WIN32
#define LL &quot;%I64d\n&quot;
#else
#define LL &quot;%lld\n&quot;
#endif
using namespace std;
inline ll read()
{
	ll f=1,x=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int maxn=5e5+6;
double val[maxn],s[maxn],a[maxn];
int d[maxn],n,ans=0,tmp=1,last[maxn],cnt=0;
struct edge{int to,next;}e[maxn&lt;&lt;1];
void dfs(int x,int fa){
#define reg(x) for(int i=last[x];i;i=e[i].next)
#define v e[i].to
    reg(x){
    	if(v==fa)continue;
    	s[v]=s[x]+log(d[x]);
    	dfs(v,x);
    }
}
int main()
{
	n=read();
	rep(i,1,n)a[i]=read();
	rep(i,1,n-1){
		int x=read(),y=read();
		e[++cnt]=(edge){x,last[y]};last[y]=cnt;
		e[++cnt]=(edge){y,last[x]};last[x]=cnt;
	    d[x]++,d[y]++;
	}
	rep(i,2,n)d[i]--;
	s[1]=log(1);
	dfs(1,0);
	rep(i,1,n)val[i]=s[i]+log(a[i]);
	sort(val+1,val+1+n);
	rep(i,2,n)
		if(abs(val[i]-val[i-1])&lt;eps)tmp++;
		else ans=max(ans,tmp),tmp=1;
	ans=max(ans,tmp);
	cout&lt;&lt;n-ans&lt;&lt;endl;
	return 0;
}</pre>
<br />
<br />

<p>
	<br />
	
</p>
