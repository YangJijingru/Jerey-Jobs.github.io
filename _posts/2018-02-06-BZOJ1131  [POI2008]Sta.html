---
tags: 
 - DP-树形
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P32.jpg"
preview-img: "/img/preview/P32.jpg"
---
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;"><strong>标签：树形<span style="margin:0px" lang="EN-US">DP</span></strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Description</strong></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>给出一个<span style="margin:0px" lang="EN-US">N</span>个点的树<span style="margin:0px" lang="EN-US">,</span>找出一个点来<span style="margin:0px" lang="EN-US">,</span>以这个点为根的树时<span style="margin:0px" lang="EN-US">,</span>所有点的深度之和最大</strong></span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Input</strong></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;"><strong>给出一个数字<span style="margin:0px" lang="EN-US">N,</span>代表有<span style="margin:0px" lang="EN-US">N</span>个点<span style="margin:0px" lang="EN-US">.N&lt;=1000000</span>下面<span style="margin:0px" lang="EN-US">N-1</span>条边<span style="margin:0px" lang="EN-US">.</span></strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Output</strong></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;"><strong>输出你所找到的点<span style="margin:0px" lang="EN-US">,</span>如果具有多个解<span style="margin:0px" lang="EN-US">,</span>请输出编号最小的那个<span style="margin:0px" lang="EN-US">.</span></strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Sample Input</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>8</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>1 4</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>5 6</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>4 5</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>6 7</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>6 8</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>2 4</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>3 4</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Sample Output</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>7</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>&nbsp;</strong></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>分析：先默认一个根节点，计算初始的答案，然后每次<span style="margin:0px" lang="EN-US">O</span>（<span style="margin:0px" lang="EN-US">1</span>）计算出其儿子节点作为根节点的<span style="margin:0px" lang="EN-US">ans</span>值，更新答案</strong></span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>&nbsp;</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Code</strong></span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"></span>
</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define mem(x,num) memset(x,num,sizeof x)
#define reg(x) for(int i=head[x];i;i=e[i].next)
#define LL long long
using namespace std;
inline LL read()
{
	LL f=1,x=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int maxn=1e6+6;
LL f[maxn],n,cnt=0,ans=0,head[maxn],deep[maxn],size[maxn];
struct edge{int to,next;}e[maxn&lt;&lt;1];
void dfs1(int x,int fa)
{
	size[x]=1;
	f[x]=deep[x];
	reg(x)
	    if(e[i].to!=fa){
			deep[e[i].to]=deep[x]+1;
			dfs1(e[i].to,x);
			f[x]+=f[e[i].to];
			size[x]+=size[e[i].to];
		}
}

void dfs2(int x,int fa)
{
	reg(x)
	    if(e[i].to!=fa)
		{
			f[e[i].to]=f[x]+n-2*size[e[i].to];
			dfs2(e[i].to,x);
		}
}
int main()
{
	n=read();
	rep(i,1,n-1){
		int u=read(),v=read();
		e[++cnt]=(edge){v,head[u]};head[u]=cnt;
		e[++cnt]=(edge){u,head[v]};head[v]=cnt;
	}
	dfs1(1,0);
	dfs2(1,0);
	rep(i,1,n)
	    if(f[i]&gt;f[ans])ans=i;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}</pre>
<br />

<p>
	<br />
	
</p>
