---
tags: 
 - 特殊-悬线法
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P9.jpg"
preview-img: "/img/preview/P9.jpg"
---
<h1>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#333333;">标签：悬线法，</span><span style="color:#333333;">DP</span></span>
</h1>
<h2>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">题目描述</span>
</h2>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8*8</span><span style="font-family:Microsoft YaHei;font-size:16px;">大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">而我们的主人公小Q</span><span style="font-family:Microsoft YaHei;font-size:16px;">，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定将棋盘扩大以适应他们的新规则。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">小Q</span><span style="font-family:Microsoft YaHei;font-size:16px;">找到了一张由N*M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">不过小Q</span><span style="font-family:Microsoft YaHei;font-size:16px;">还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">于是小Q</span><span style="font-family:Microsoft YaHei;font-size:16px;">找到了即将参加全国信息学竞赛的你，你能帮助他么？</span>
</p>
<h2>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">输入输出格式</span>
</h2>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#515151;">输入格式：</span></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">包含两个整数N</span><span style="font-family:Microsoft YaHei;font-size:16px;">和M，分别表示矩形纸片的长和宽。接下来的N行包含一个N * M的01矩阵，表示这张矩形纸片的颜色（0表示白色，1表示黑色）。</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#515151;">输出格式：</span></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。</span>
</p>
<h2>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">输入输出样例</span>
</h2>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#515151;">输入样例#1</span>：</span>
</p>
<div style="background:#F8F8F8">
	<pre style="background:#F8F8F8"><span style="font-family:Microsoft YaHei;font-size:16px;color:#555555;background:#F8F8F8">3 3</span></pre>
	<pre style="background:#F8F8F8"><span style="font-family:Microsoft YaHei;font-size:16px;color:#555555;background:#F8F8F8">1 0 1</span></pre>
	<pre style="background:#F8F8F8"><span style="font-family:Microsoft YaHei;font-size:16px;color:#555555;background:#F8F8F8">0 1 0</span></pre>
	<pre style="background:#F8F8F8"><span style="font-family:Microsoft YaHei;font-size:16px;color:#555555;background:#F8F8F8">1 0 0</span></pre>
</div>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;"><span style="color:#515151;">输出样例#1</span>：</span>
</p>
<div style="background:#F8F8F8">
	<pre style="background:#F8F8F8"><span style="font-family:Microsoft YaHei;font-size:16px;color:#555555;background:#F8F8F8">4</span></pre>
	<pre style="background:#F8F8F8"><span style="font-family:Microsoft YaHei;font-size:16px;color:#555555;background:#F8F8F8">6</span></pre>
</div>
<h2>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">说明</span>
</h2>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">对于20%</span><span style="font-family:Microsoft YaHei;font-size:16px;">的数据，N,M ≤ 80</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">对于40%</span><span style="font-family:Microsoft YaHei;font-size:16px;">的数据，N,M ≤ 400</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;color:#333333;">对于100%</span><span style="font-family:Microsoft YaHei;font-size:16px;">的数据，N,M ≤ 2000</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;"><br />
	</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">分析：</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">给定：N*M的矩阵</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">求：面积最大的正方形和子矩阵</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">满足：若a[i][j]=0，则a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1]都为1</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">若a[i][j]=1，则a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1]都为0</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">且a[i][j]∈求的子矩阵（1&lt;=i&lt;=n,1&lt;=j&lt;=m）</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">悬线法（奇奇怪怪的神奇套路）</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">可以参考：王知昆《浅谈用极大化思想解决最大子矩阵问题》</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">那篇论文里讲解的很清楚了</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">对每个点处理从上到该点最大的高度和最长的左右高度，然后DP求面积，取最大</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">面积sqare=h[i][j]*(r[i][j]-l[i][j]+1)</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Code</span>
</p>
<pre name="code" class="cpp">#include&lt;bits/stdc++.h&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define LL long long
#define reg(x) for(int i=last[x];i;i=e[i].to)
using namespace std;
const int maxn=2006;
int n,m,a[maxn][maxn],h[maxn][maxn],l[maxn][maxn];
int r[maxn][maxn],ans1=0,ans2=0;

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    rep(i,1,n)
       rep(j,1,m){
               scanf(&quot;%d&quot;,&amp;a[i][j]);
               if(i==1)h[i][j]=1;
               else if(a[i][j]!=a[i-1][j])h[i][j]=h[i-1][j]+1;
               else h[i][j]=1;
           }
    rep(i,1,n){
        rep(j,1,m){
            l[i][j]=j;
            while(l[i][j]&gt;1&amp;&amp;h[i][l[i][j]-1]&gt;=h[i][j]&amp;&amp;a[i][l[i][j]]!=a[i][l[i][j]-1])
            l[i][j]=l[i][l[i][j]-1];
        }
        dep(j,m,1){
            r[i][j]=j;
            while(r[i][j]&lt;n&amp;&amp;h[i][r[i][j]+1]&gt;=h[i][j]&amp;&amp;a[i][r[i][j]]!=a[i][r[i][j]+1])
            r[i][j]=r[i][r[i][j]+1];
        }
        rep(j,1,m){
            int temp=r[i][j]-l[i][j]+1;
            ans2=max(ans2,temp*h[i][j]);
            ans1=max(ans1,min(temp,h[i][j])*min(temp,h[i][j]));
        }
    }
    printf(&quot;%d\n%d\n&quot;,ans1,ans2);
    return 0;
}
</pre>
<br />
<br />

<p>
	<br />
	
</p>
