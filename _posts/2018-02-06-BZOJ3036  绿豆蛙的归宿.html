---
tags: 
 - 基础算法-dfs
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P32.jpg"
preview-img: "/img/preview/P72.jpg"
---
<p style="text-align:left" align="center">
    <span style="color:blue;font-weight:bold">标签：图的遍历，数学期望</span>
</p>
<p align="left">
    <strong><span style="color:blue;">Description</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
    随着新版百度空间的下线，Blog宠物绿豆蛙完成了它的使命，去寻找它新的归宿。
</p>
<p style="background:rgb(228,240,248)" align="left">
    给出一个有向无环的连通图，起点为1终点为N，每条边都有一个长度。绿豆蛙从起点出发，走向终点。<br />
    到达每一个顶点时，如果有K条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 1/K 。<br />
    现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？
</p>
<p align="left">
    <strong><span style="color:blue;">Input</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
    第一行: 两个整数 N M，代表图中有N个点、M条边<br />
    第二行到第 1+M 行: 每行3个整数 a b c，代表从a到b有一条长度为c的有向边
</p>
<p align="left">
    <strong><span style="color:blue;">Output</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
    <br />
    从起点到终点路径总长度的期望值，四舍五入保留两位小数。
</p>
<p style="background:rgb(228,240,248)" align="left">
    &nbsp;
</p>
<p align="left">
    <strong><span style="color:blue;">Sample Input</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
    4 4<span style="background:rgb(141,184,255)"><br />
    <br />
    </span>
</p>
<p style="background:rgb(228,240,248)" align="left">
    1 2 1<span style="background:rgb(141,184,255)"><br />
    <br />
    </span>
</p>
<p style="background:rgb(228,240,248)" align="left">
    1 3 2<span style="background:rgb(141,184,255)"><br />
    <br />
    </span>
</p>
<p style="background:rgb(228,240,248)" align="left">
    2 3 3<span style="background:rgb(141,184,255)"><br />
    <br />
    </span>
</p>
<p style="background:rgb(228,240,248)" align="left">
    3 4 4<span style="background:rgb(141,184,255)"><br />
    <br />
    </span>
</p>
<p style="background:rgb(228,240,248)" align="left">
    <span style="background:rgb(141,184,255)"><br />
    <br />
    </span>
</p>
<p align="left">
    <strong><span style="color:blue;">Sample Output</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
    7.00
</p>
<p align="left">
    <strong><span style="color:blue;">HINT</span></strong>
</p>
<p style="background:rgb(228,240,248)" align="left">
    <br />
    <br />
    对于100%的数据&nbsp; N&lt;=100000，M&lt;=2*N
</p>
<p>
    珍惜NOIP前最后的刷水机会2333
</p>
<p>
    Code
</p>
<pre name="code" class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define ll long long
#define mem(x,num) memset(x,num,sizeof x)
#ifdef WIN32
#define LL &quot;%I64d&quot;
#else
#define LL &quot;%lld&quot;
#endif
using namespace std;
inline ll read()
{
    ll f=1,x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
const int maxn=1e5+6;
int n,m,last[maxn],vis[maxn],r[maxn]={0};
struct edge{int to,next,w;}e[maxn&lt;&lt;1];
double f[maxn];
void dfs(int x)
{
    if(!vis[x])vis[x]=1;
    else return;
#define reg(x) for(int i=last[x];i;i=e[i].next)
#define v e[i].to
    reg(x){
        dfs(v);
        f[x]+=e[i].w+f[v];
    }
    if(r[x])f[x]/=r[x];
}
int main()
{
    n=read(),m=read();
    rep(i,1,m){
        int x=read(),y=read(),z=read();
        e[i]=(edge){y,last[x],z};last[x]=i;
        r[x]++;
    }
    dfs(1);
    printf(&quot;%.2lf\n&quot;,f[1]);
    return 0;
}
</pre>
<br />
<br />

<p>
    <br />
    
</p>
