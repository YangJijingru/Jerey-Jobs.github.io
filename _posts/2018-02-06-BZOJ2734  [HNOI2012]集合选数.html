---
tags: 
 - DP-状压
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P27.jpg"
preview-img: "/img/preview/P67.jpg"
---
<p style="margin:0px">
	<strong><span style="font-family:Microsoft YaHei;"><span style="font-size:16px;">标签：状压<span style="margin:0px" lang="EN-US">DP</span></span></span></strong>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Description</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;">《集合论与图论》这门课程有一道作业题，要求同学们求出<span style="margin:0px" lang="EN-US">{1, 2, 3, 4, 5}</span>的所有满足以下条件的子集：若<span style="margin:0px" lang="EN-US"> x</span>在该子集中，则<span style="margin:0px" lang="EN-US"> 2x </span>和<span style="margin:0px" lang="EN-US"> 3x</span>不能在该子集中。同学们不喜欢这种具有枚举性 质的题目，于是把它变成了以下问题：对于任意一个正整数<span style="margin:0px" lang="EN-US"> n≤100000</span>，如何求出<span style="margin:0px" lang="EN-US">{1, 2,..., n}</span>的满足上述约束条件的子集的个数（只需输出对<span style="margin:0px" lang="EN-US"> 1,000,000,001 </span>取模的结果），现在这个问题就 交给你了。<span style="margin:0px" lang="EN-US">&nbsp;<br />
	&nbsp;</span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Input</span></span></strong>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;"><span style="margin:0px" lang="EN-US">&nbsp;</span>只有一行，其中有一个正整数<span style="margin:0px" lang="EN-US">n</span>，<span style="margin:0px" lang="EN-US">30%</span>的数据满足<span style="margin:0px" lang="EN-US"> n≤20</span>。<span style="margin:0px" lang="EN-US">&nbsp;</span></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;"><strong><span style="margin:0px" lang="EN-US">Output</span></strong><span style="margin:0px" lang="EN-US"><br />
	&nbsp;</span>仅包含一个正整数，表示<span style="margin:0px" lang="EN-US">{1, 2,..., n}</span>有多少个满足上述约束条件 的子集。<span style="margin:0px" lang="EN-US">&nbsp;</span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Input</span></span></strong>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;"><span style="font-size:16px;">4<span style="margin:0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span></span>
</p>
<p style="margin:0px">
	<strong><span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Sample Output</span></span></strong>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">8</span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">【样例解释】</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">有<span style="margin:0px" lang="EN-US">8</span>个集合满足要求，分别是空集，<span style="margin:0px" lang="EN-US">{1}</span>，<span style="margin:0px" lang="EN-US">{1</span>，<span style="margin:0px" lang="EN-US">4}</span>，<span style="margin:0px" lang="EN-US">{2}</span>，<span style="margin:0px" lang="EN-US">{2</span>，<span style="margin:0px" lang="EN-US">3}</span>，<span style="margin:0px" lang="EN-US">{3}</span>，<span style="margin:0px" lang="EN-US">{3</span>，<span style="margin:0px" lang="EN-US">4}</span>，<span style="margin:0px" lang="EN-US">{4}</span>。</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">题意：定义一个符合要求的集合为<span style="margin:0px" lang="EN-US">a</span>与<span style="margin:0px" lang="EN-US">2a,a</span>与<span style="margin:0px" lang="EN-US">3a</span>不能同时存在，<span style="margin:0px" lang="EN-US">{x|1&lt;=x&lt;=n}</span>的所有子集中有多少个符合要求</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">可以列出来一个奇奇怪怪的矩阵</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px 0px 0px 24px; text-indent:-18pt">
	<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="margin:0px" lang="EN-US"><span style="margin:0px">1<span style="margin:0px; line-height:normal; font-style:normal; font-variant:normal; font-weight:normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="margin:0px" lang="EN-US">3<span style="margin:0px">&nbsp;</span>9</span></span></span>
</p>
<p style="margin:0px 0px 0px 24px; text-indent:-18pt">
	<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="margin:0px" lang="EN-US"><span style="margin:0px">2<span style="margin:0px; line-height:normal; font-style:normal; font-variant:normal; font-weight:normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="margin:0px" lang="EN-US">6<span style="margin:0px">&nbsp;</span>18</span></span></span>
</p>
<p style="margin:0px 0px 0px 24px; text-indent:-18pt">
	<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="margin:0px" lang="EN-US"><span style="margin:0px">4<span style="margin:0px; line-height:normal; font-style:normal; font-variant:normal; font-weight:normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="margin:0px" lang="EN-US">12<span style="margin:0px">&nbsp;</span>36…….</span></span></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">这个矩阵向右<span style="margin:0px" lang="EN-US">*2</span>，向下<span style="margin:0px" lang="EN-US">*3</span>，矩阵中任何两个相邻的数的<span style="margin:0px" lang="EN-US">x</span>倍都不能出现在同一个集合中</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">可以将方案数状压<span style="margin:0px" lang="EN-US">DP</span>，最后将方案数用乘法原理相乘就可以了</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;"><span style="font-size:16px;"><span style="margin:0px" lang="EN-US">F[i][j]</span>表示前<span style="margin:0px" lang="EN-US">i</span>行且第<span style="margin:0px" lang="EN-US">i</span>行状态为<span style="margin:0px" lang="EN-US">j</span>时的方案数，转化为状压经典裸题</span></span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="font-family:Microsoft YaHei;font-size:16px;">好妙的一道题呐</span><span style="margin:0px" lang="EN-US"></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"><span style="font-family:Microsoft YaHei;font-size:16px;">Code</span></span>
</p>
<p style="margin:0px">
	<span style="margin:0px" lang="EN-US"></span>
</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,a,b) for(int i=a;i&lt;=b;i++)
#define dep(i,a,b) for(int i=a;i&gt;=b;i--)
#define LL long long
#define mem(x,num) memset(x,num,sizeof x)
using namespace std;
const LL mod=1000000001;
const int maxn=20;
LL bin[maxn],n,a[maxn][maxn],b[maxn],f[maxn][1&lt;&lt;12],ans=1;
bool mark[100006];

LL cal(LL x){
	mem(b,0);
	a[1][1]=x;
	rep(i,2,18)
		if(a[i-1][1]*2&lt;=n)a[i][1]=a[i-1][1]*2;
			else a[i][1]=n+1;
	rep(i,1,18)
		rep(j,2,11)
			if(a[i][j-1]*3&lt;=n)a[i][j]=a[i][j-1]*3;
				else a[i][j]=n+1;//扩展n以内的x矩阵 
	rep(i,1,18)
		rep(j,1,11)
			if(a[i][j]&lt;=n)b[i]+=bin[j-1],mark[a[i][j]]=1;
	rep(i,0,18)
		rep(x,0,b[i])f[i][x]=0;
	f[0][0]=1;
	rep(i,0,17)
		rep(x,0,b[i])
			if(f[i][x])
				rep(y,0,b[i+1])
			        if(((x&amp;y)==0)&amp;&amp;((y&amp;(y&gt;&gt;1))==0))f[i+1][y]=(f[i+1][y]+f[i][x])%mod;
    return f[18][0];
}
int main()
{
	scanf(&quot;%lld&quot;,&amp;n);
	bin[0]=1;
	rep(i,1,19)bin[i]=bin[i-1]&lt;&lt;1;
	rep(i,1,n)
	    if(!mark[i])ans=(ans*cal(i))%mod;//mark[i]表示这个数是否已经在集合内 
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}</pre>
<br />

<p>
	<br />
	
</p>
<br />