---
tags: 
 - 数据结构-并查集
grammar_cjkRuby: true
catalog: true
layout:  post
header-img: "img/header/P31.jpg"
preview-img: "/img/preview/P71.jpg"
---
<h1>
	<span style="font-family:Microsoft YaHei;font-size:16px;">POJ1182食物链</span>
</h1>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">标签：并查集</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">http://www.sakurasake.icoc.me/nd.jsp?id=3#_np=2_327<br />
	</span>
</p>
<div align="center">
	<table class=" " cellspacing="3" cellpadding="0" border="0">
		<tbody>
			<tr>
				<td>
					<p align="left">
						<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Time Limit:</strong> 1000MS</span>
					</p>
				</td>
				<td>
					<span style="font-family:Microsoft YaHei;font-size:16px;"><br />
					</span>
				</td>
				<td>
					<p align="left">
						<span style="font-family:Microsoft YaHei;font-size:16px;"><strong>Memory Limit:</strong> 10000K</span>
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</div>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">Description</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br />
	现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 <br />
	有人用两种说法对这N个动物所构成的食物链关系进行描述： <br />
	第一种说法是&quot;1 X Y&quot;，表示X和Y是同类。 <br />
	第二种说法是&quot;2 X Y&quot;，表示X吃Y。 <br />
	此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br />
	1） 当前的话与前面的某些真的话冲突，就是假话； <br />
	2） 当前的话中X或Y比N大，就是假话； <br />
	3） 当前的话表示X吃X，就是假话。 <br />
	你的任务是根据给定的N（1 &lt;= N &lt;=50,000）和K句话（0 &lt;= K &lt;=100,000），输出假话的总数。 </span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">Input</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">第一行是两个整数N和K，以一个空格分隔。<br />
	以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 <br />
	若D=1，则表示X和Y是同类。 <br />
	若D=2，则表示X吃Y。</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">Output</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">只有一个整数，表示假话的数目。</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">Sample Input</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">100 7</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">1 101 1</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">2 1 2</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">2 2 3 </span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">2 3 3 </span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">1 1 3 </span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">2 3 1 </span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">1 5 5</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">Sample Output</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">3</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;">Source</span>
</p>
<p align="left">
	<span style="font-family:Microsoft YaHei;font-size:16px;"><a target="_blank" href="http://poj.org/searchproblem?field=source&amp;key=Noi+01"><span style="color:blue;">Noi 01</span></a></span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">&nbsp;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">分析：用动物之间的关系来确定并查集</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">设f[x]表示x的根节点，rank[x]表示f[x]与x的关系</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Rank[x]==0表示f[x]与x同类，rank[x]==1表示f[x]吃x，rank[x]==2表示x吃f[x]</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">假设已读入d,x,y</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">先利用find（）函数得到x,y分别的根节点root1，root2</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若d==1&amp;&amp;rank[x]!=rank[y]那么这句话为假</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">因为d==1表示x与y为同类，而rank[x]!=rank[y]可以推出不同类，矛盾</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若d==2&amp;&amp;rank[x]==rank[y]（或者rank[x]==(rank[y]+1)%3）那么此话为假</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">因为d==2表示x吃y，即不同类，而rank[x]==rank[y]可以推出同类，矛盾</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">假设有y吃x，那么rank[x]与rank[y]的值会有那些可能？？</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">列举如下：</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Rank[x]==0&amp;&amp;rank[y]==2;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Rank[x]==1&amp;&amp;rank[y]==0;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">Rank[x]==2&amp;&amp;rank[y]==1;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">简单观察发现rank[x]=(rank[y]+1)%3;</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">敲黑板！！重点来了！！！</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">对于上个问题有个更一般的判断方法：</span>
</p>
<p>
	<span style="font-family:Microsoft YaHei;font-size:16px;">若（rank[y]-rank[x]+3）%3!=d-1，那么此话为假。</span>
</p>
<pre name="code" class="cpp"><span style="font-family:Microsoft YaHei;font-size:16px;">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;ctime&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
inline int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
using namespace std;
int f[50005];
int rank[50005];

int find(int x)
{
	int t;
	if(x==f[x])return x;
	else 
	{
		t=f[x];
		f[x]=find(f[x]);//路径压缩
		rank[x]=(rank[x]+rank[t])%3;
		return f[x];
	}
}

int main()
{
	int total=0;
	int i,n,k,x,y,d,root1,root2;
	n=read();k=read();
	for(i=1;i&lt;=n;i++){f[i]=i;rank[i]=0;}//初始化
	while(k--)
	{
		d=read();x=read();y=read();
		if(x&gt;n||y&gt;n||(d==2&amp;&amp;x==y))total++;//根据题意初步判断
		else{
			root1=find(x);root2=find(y);
			if(root1==root2)
			{
				if((rank[x]-rank[y]+3)%3!=d-1)total++;
			}
			else 
			{
				f[root1]=root2;
				rank[root1]=(rank[y]-rank[x]+3+d-1)%3;
			}//合并x,y
		}
	}
	cout&lt;&lt;total&lt;&lt;endl;
	return 0;
}

</span></pre>
<span style="font-family:Microsoft YaHei;font-size:16px;"><br />
</span><br />

<p>
	<br />
	
</p>
